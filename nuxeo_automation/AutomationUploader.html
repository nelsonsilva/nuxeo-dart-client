        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>AutomationUploader class / nuxeo_automation Library / Dart Automation Client Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="nuxeo_automation" data-type="AutomationUploader">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Automation Client Documentation</a>
         &rsaquo; <a href="../nuxeo_automation.html">nuxeo_automation</a> &rsaquo; <a href="../nuxeo_automation/AutomationUploader.html">AutomationUploader</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>AutomationUploader</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p><a class="crossref" href="../nuxeo_automation/AutomationUploader.html">AutomationUploader</a> manages the upload of files in a queue with a target
number of concurrent uploads.</p>
<pre class="source">
class AutomationUploader {

 static final LOG = new Logger("nuxeo.automation.uploader");

 Uri uri;
 http.Client client;

 StreamController&lt;AutomationUploaderEvent&gt; evtController = new StreamController&lt;AutomationUploaderEvent&gt;();
 Stream&lt;AutomationUploaderEvent&gt; get onBatchStarted =&gt; evtController.stream.where((e) =&gt; e.type == "batchStarted");

 int numConcurrentUploads;

 // define if upload should be triggered directly
 bool directUpload;

 // update upload speed every second
 num uploadRateRefreshTime;

 num uploadTimeout;

 String batchId;
 bool _sendingRequestsInProgress = false;
 Queue&lt;Upload&gt; _uploadStack = new Queue();
 int _uploadIdx = 0;
 int _nbUploadInprogress = 0;
 List _completedUploads = [];

 AutomationUploader(this.uri, this.client, {
   this.numConcurrentUploads : 5,
   // define if upload should be triggered directly
   this.directUpload : true,
   // update upload speed every second
   this.uploadRateRefreshTime : 1000,
   this.uploadTimeout : 0
 }) {
   batchId = "batch-" +
       new DateTime.now().millisecondsSinceEpoch.toString() +
       "-" + new Math.Random().nextInt(100000).toString();
 }

 Future&lt;Upload&gt; uploadFile(cfile) {
   var entry = new Upload(cfile);
   _uploadStack.add(entry);
   if (directUpload &amp;&amp; !_sendingRequestsInProgress &amp;&amp; _uploadStack.isNotEmpty) {
     uploadFiles();
   }
   return entry.future;
 }

 uploadFiles() {

   if (_nbUploadInprogress &gt;= numConcurrentUploads) {
     _sendingRequestsInProgress = false;
     LOG.info("delaying upload for next file(s) $_uploadIdx"
           "+ since there are already $_nbUploadInprogress"
           " active uploads");
     return;
   }

   // this.opts.handler.batchStarted();
   _sendingRequestsInProgress = true;

   while (_uploadStack.isNotEmpty) {

     var upload = _uploadStack.removeFirst();

     // create a new xhr object
     var xhr = client.post(Uri.parse("${uri}/batch/upload"));

     upload.fileIndex = _uploadIdx + 0;
     upload.downloadStartTime = new DateTime.now();
     upload.currentStart = upload.downloadStartTime;
     upload.currentProgress = 0;
     upload.startData = 0;
     upload.batchId = batchId;

     var file = upload.file;

     _nbUploadInprogress++;


     //var upload = xhr.upload;

     // add listeners
     //xhr.upload.onProgress.listen(_progress);

     //if (file.callback) {
     //  upload.callback = file.callback;
     //}

     // The "load" event doesn't work correctly on WebKit (Chrome,
     // Safari),
     // it fires too early, before the server has returned its response.
     // still it is required for Firefox
     //if (navigator.userAgent.indexOf('Firefox') &gt; -1) {
     //  upload.addEventListener("load", function(event) {
     //    log("trigger load");
     //    log(event);
     //    me.load(event.target)
     //  }, false);
     //}

     // on ready state change is not fired in all cases on webkit
     // - on webkit we rely on progress lister to detected upload end
     // - but on Firefox the event we need it
     //xhr.onreadystatechange = (function(xhr) {
     //  return function() {
     //    me.readyStateChange(xhr)
     //  }
     //})(xhr);

     // compute timeout in seconds and integer
     var uploadTimeoutS = 5 + (uploadTimeout / 1000);

     LOG.info("starting upload for file $_uploadIdx");

     xhr.headers.set("Cache-Control", "no-cache");
     xhr.headers.set("X-Requested-With", "XMLHttpRequest");
     xhr.headers.set("X-File-Name", Uri.encodeComponent(file.filename));
     xhr.headers.set("X-File-Size", file.length.toString());
     xhr.headers.set("X-File-Type", file.mimetype);
     xhr.headers.set("X-Batch-Id", batchId);
     xhr.headers.set("X-File-Idx", _uploadIdx.toString());

     xhr.headers.set('Nuxeo-Transaction-Timeout', uploadTimeoutS.toString());
     xhr.headers.set("Content-Type", "multipart/form-data");

     //this.opts.handler.uploadStarted(_uploadIdx, file);
     _uploadIdx++;

     xhr.send(file).then((response) {
       load(upload);
     });

     if (_nbUploadInprogress &gt;= numConcurrentUploads) {
       _sendingRequestsInProgress = false;
       LOG.info("delaying upload for next file(s) $_uploadIdx"
             "+ since there are already "
             "$_nbUploadInprogress active uploads");
       return;
     }
     _sendingRequestsInProgress = false;
   }

 }
 /*
 readyStateChange : function(xhr) {
   var upload = xhr.upload;
   log("readyStateChange event on file upload " + upload.fileIndex
       + " (state : " + xhr.readyState + ")");
   if (xhr.readyState == 4) {
     if (xhr.status == 200) {
       this.load(upload);
     } else {
       log("Upload failed, status: " + xhr.status);
     }
   }
 },*/

 load(Upload upload) {
   var fileIdx = upload.fileIndex;
   LOG.info("Received loaded event on  file $fileIdx");
   if (!_completedUploads.contains(fileIdx)) {
     _completedUploads.add(fileIdx);
   } else {
     LOG.info("Event already processsed for file $fileIdx, exiting");
     return;
   }

   //this.opts.handler.uploadFinished(upload.fileIndex, upload.file,timeDiff);
   LOG.info("upload of file ${upload.fileIndex} completed");

   upload.complete();

   _nbUploadInprogress--;
   if (!_sendingRequestsInProgress &amp;&amp; _uploadStack.isNotEmpty
       &amp;&amp; _nbUploadInprogress &lt; numConcurrentUploads) {
     // restart upload
     LOG.info("restart pending uploads");
     uploadFiles();
   } else if (_nbUploadInprogress == 0) {
     //this.opts.handler.batchFinished(this.batchId);
   }
 }

 /*
 _progress : function(event) {
   log(event);
   if (event.lengthComputable) {
     var percentage = Math.round((event.loaded * 100) / event.total);
     if (event.target.currentProgress != percentage) {

       log("progress event on upload of file "
           + event.target.fileIndex + " --&gt; " + percentage + "%");

       event.target.currentProgress = percentage;
       this.opts.handler.fileUploadProgressUpdated(
           event.target.fileIndex, event.target.fileObj,
           event.target.currentProgress);

       var elapsed = new Date().getTime();
       var diffTime = elapsed - event.target.currentStart;
       if (diffTime &gt;= this.opts.handler.uploadRateRefreshTime) {
         var diffData = event.loaded - event.target.startData;
         var speed = diffData / diffTime; // in KB/sec

         this.opts.handler
             .fileUploadSpeedUpdated(event.target.fileIndex,
                 event.target.fileObj, speed);

         event.target.startData = event.loaded;
         event.target.currentStart = elapsed;
       }
       if (event.loaded == event.total) {
         log("file " + event.target.fileIndex
             + " detected upload complete");
         // having all the bytes sent to the server does not mean the
         // server did actually receive everything
         // but since load event is not reliable on Webkit we need
         // this
         // window.setTimeout(function(){load(event.target, opts);},
         // 5000);
       } else {
         log("file " + event.target.fileIndex + " not completed :"
             + event.loaded + "/" + event.total);
       }
     }
   }
 }*/

}
</pre>
</div>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="LOG">
<button class="show-code">Code</button>
final         <strong>LOG</strong> <a class="anchor-link"
            href="#LOG"
            title="Permalink to AutomationUploader.LOG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static final LOG = new Logger("nuxeo.automation.uploader")
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>AutomationUploader</strong>(<a href="http://api.dartlang.org/dart_core/Uri.html">Uri</a> uri, <a href="../http_client/Client.html">Client</a> client, {<a href="http://api.dartlang.org/dart_core/int.html">int</a> numConcurrentUploads: 5, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> directUpload: true, <a href="http://api.dartlang.org/dart_core/num.html">num</a> uploadRateRefreshTime: 1000, <a href="http://api.dartlang.org/dart_core/num.html">num</a> uploadTimeout: 0}) <a class="anchor-link" href="#"
              title="Permalink to AutomationUploader.AutomationUploader">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Creates a new <a class="crossref" href="../dart_core/Object.html">Object</a> instance.</p>
<p><a class="crossref" href="../dart_core/Object.html">Object</a> instances have no meaningful state, and are only useful
through their identity. An <a class="crossref" href="../dart_core/Object.html">Object</a> instance is equal to itself
only.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html">Object</a> </div></div>
<pre class="source">
AutomationUploader(this.uri, this.client, {
 this.numConcurrentUploads : 5,
 // define if upload should be triggered directly
 this.directUpload : true,
 // update upload speed every second
 this.uploadRateRefreshTime : 1000,
 this.uploadTimeout : 0
}) {
 batchId = "batch-" +
     new DateTime.now().millisecondsSinceEpoch.toString() +
     "-" + new Math.Random().nextInt(100000).toString();
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="batchId">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>batchId</strong> <a class="anchor-link"
            href="#batchId"
            title="Permalink to AutomationUploader.batchId">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String batchId
</pre>
</div>
</div>
<div class="field"><h4 id="client">
<button class="show-code">Code</button>
<a href="../http_client/Client.html">Client</a>         <strong>client</strong> <a class="anchor-link"
            href="#client"
            title="Permalink to AutomationUploader.client">#</a>
        </h4>
        <div class="doc">
<pre class="source">
http.Client client
</pre>
</div>
</div>
<div class="field"><h4 id="directUpload">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>         <strong>directUpload</strong> <a class="anchor-link"
            href="#directUpload"
            title="Permalink to AutomationUploader.directUpload">#</a>
        </h4>
        <div class="doc">
<pre class="source">
bool directUpload
</pre>
</div>
</div>
<div class="field"><h4 id="evtController">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/StreamController.html">StreamController</a>&lt;<a href="../nuxeo_automation/AutomationUploaderEvent.html">AutomationUploaderEvent</a>&gt;         <strong>evtController</strong> <a class="anchor-link"
            href="#evtController"
            title="Permalink to AutomationUploader.evtController">#</a>
        </h4>
        <div class="doc">
<pre class="source">
StreamController&lt;AutomationUploaderEvent&gt; evtController = new StreamController&lt;AutomationUploaderEvent&gt;()
</pre>
</div>
</div>
<div class="field"><h4 id="numConcurrentUploads">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/int.html">int</a>         <strong>numConcurrentUploads</strong> <a class="anchor-link"
            href="#numConcurrentUploads"
            title="Permalink to AutomationUploader.numConcurrentUploads">#</a>
        </h4>
        <div class="doc">
<pre class="source">
int numConcurrentUploads
</pre>
</div>
</div>
<div class="field"><h4 id="onBatchStarted">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_async/Stream.html">Stream</a>&lt;<a href="../nuxeo_automation/AutomationUploaderEvent.html">AutomationUploaderEvent</a>&gt;         <strong>onBatchStarted</strong> <a class="anchor-link"
            href="#onBatchStarted"
            title="Permalink to AutomationUploader.onBatchStarted">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Stream&lt;AutomationUploaderEvent&gt; get onBatchStarted =&gt; evtController.stream.where((e) =&gt; e.type == "batchStarted");
</pre>
</div>
</div>
<div class="field"><h4 id="uploadRateRefreshTime">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>uploadRateRefreshTime</strong> <a class="anchor-link"
            href="#uploadRateRefreshTime"
            title="Permalink to AutomationUploader.uploadRateRefreshTime">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num uploadRateRefreshTime
</pre>
</div>
</div>
<div class="field"><h4 id="uploadTimeout">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/num.html">num</a>         <strong>uploadTimeout</strong> <a class="anchor-link"
            href="#uploadTimeout"
            title="Permalink to AutomationUploader.uploadTimeout">#</a>
        </h4>
        <div class="doc">
<pre class="source">
num uploadTimeout
</pre>
</div>
</div>
<div class="field"><h4 id="uri">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Uri.html">Uri</a>         <strong>uri</strong> <a class="anchor-link"
            href="#uri"
            title="Permalink to AutomationUploader.uri">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Uri uri
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="load">
<button class="show-code">Code</button>
dynamic <strong>load</strong>(<a href="../nuxeo_automation/Upload.html">Upload</a> upload) <a class="anchor-link" href="#load"
              title="Permalink to AutomationUploader.load">#</a></h4>
<div class="doc">
<pre class="source">
load(Upload upload) {
 var fileIdx = upload.fileIndex;
 LOG.info("Received loaded event on  file $fileIdx");
 if (!_completedUploads.contains(fileIdx)) {
   _completedUploads.add(fileIdx);
 } else {
   LOG.info("Event already processsed for file $fileIdx, exiting");
   return;
 }

 //this.opts.handler.uploadFinished(upload.fileIndex, upload.file,timeDiff);
 LOG.info("upload of file ${upload.fileIndex} completed");

 upload.complete();

 _nbUploadInprogress--;
 if (!_sendingRequestsInProgress &amp;&amp; _uploadStack.isNotEmpty
     &amp;&amp; _nbUploadInprogress &lt; numConcurrentUploads) {
   // restart upload
   LOG.info("restart pending uploads");
   uploadFiles();
 } else if (_nbUploadInprogress == 0) {
   //this.opts.handler.batchFinished(this.batchId);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="uploadFile">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../nuxeo_automation/Upload.html">Upload</a>&gt; <strong>uploadFile</strong>(cfile) <a class="anchor-link" href="#uploadFile"
              title="Permalink to AutomationUploader.uploadFile">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;Upload&gt; uploadFile(cfile) {
 var entry = new Upload(cfile);
 _uploadStack.add(entry);
 if (directUpload &amp;&amp; !_sendingRequestsInProgress &amp;&amp; _uploadStack.isNotEmpty) {
   uploadFiles();
 }
 return entry.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="uploadFiles">
<button class="show-code">Code</button>
dynamic <strong>uploadFiles</strong>() <a class="anchor-link" href="#uploadFiles"
              title="Permalink to AutomationUploader.uploadFiles">#</a></h4>
<div class="doc">
<pre class="source">
uploadFiles() {

 if (_nbUploadInprogress &gt;= numConcurrentUploads) {
   _sendingRequestsInProgress = false;
   LOG.info("delaying upload for next file(s) $_uploadIdx"
         "+ since there are already $_nbUploadInprogress"
         " active uploads");
   return;
 }

 // this.opts.handler.batchStarted();
 _sendingRequestsInProgress = true;

 while (_uploadStack.isNotEmpty) {

   var upload = _uploadStack.removeFirst();

   // create a new xhr object
   var xhr = client.post(Uri.parse("${uri}/batch/upload"));

   upload.fileIndex = _uploadIdx + 0;
   upload.downloadStartTime = new DateTime.now();
   upload.currentStart = upload.downloadStartTime;
   upload.currentProgress = 0;
   upload.startData = 0;
   upload.batchId = batchId;

   var file = upload.file;

   _nbUploadInprogress++;


   //var upload = xhr.upload;

   // add listeners
   //xhr.upload.onProgress.listen(_progress);

   //if (file.callback) {
   //  upload.callback = file.callback;
   //}

   // The "load" event doesn't work correctly on WebKit (Chrome,
   // Safari),
   // it fires too early, before the server has returned its response.
   // still it is required for Firefox
   //if (navigator.userAgent.indexOf('Firefox') &gt; -1) {
   //  upload.addEventListener("load", function(event) {
   //    log("trigger load");
   //    log(event);
   //    me.load(event.target)
   //  }, false);
   //}

   // on ready state change is not fired in all cases on webkit
   // - on webkit we rely on progress lister to detected upload end
   // - but on Firefox the event we need it
   //xhr.onreadystatechange = (function(xhr) {
   //  return function() {
   //    me.readyStateChange(xhr)
   //  }
   //})(xhr);

   // compute timeout in seconds and integer
   var uploadTimeoutS = 5 + (uploadTimeout / 1000);

   LOG.info("starting upload for file $_uploadIdx");

   xhr.headers.set("Cache-Control", "no-cache");
   xhr.headers.set("X-Requested-With", "XMLHttpRequest");
   xhr.headers.set("X-File-Name", Uri.encodeComponent(file.filename));
   xhr.headers.set("X-File-Size", file.length.toString());
   xhr.headers.set("X-File-Type", file.mimetype);
   xhr.headers.set("X-Batch-Id", batchId);
   xhr.headers.set("X-File-Idx", _uploadIdx.toString());

   xhr.headers.set('Nuxeo-Transaction-Timeout', uploadTimeoutS.toString());
   xhr.headers.set("Content-Type", "multipart/form-data");

   //this.opts.handler.uploadStarted(_uploadIdx, file);
   _uploadIdx++;

   xhr.send(file).then((response) {
     load(upload);
   });

   if (_nbUploadInprogress &gt;= numConcurrentUploads) {
     _sendingRequestsInProgress = false;
     LOG.info("delaying upload for next file(s) $_uploadIdx"
           "+ since there are already "
           "$_nbUploadInprogress active uploads");
     return;
   }
   _sendingRequestsInProgress = false;
 }

}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
