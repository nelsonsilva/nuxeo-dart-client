        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>OperationRequest class / nuxeo_automation Library / Dart Automation Client Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="nuxeo_automation" data-type="OperationRequest">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Automation Client Documentation</a>
         &rsaquo; <a href="../nuxeo_automation.html">nuxeo_automation</a> &rsaquo; <a href="../nuxeo_automation/OperationRequest.html">OperationRequest</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>OperationRequest</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p><a class="crossref" href="../nuxeo_automation/OperationRequest.html">OperationRequest</a> wraps an <a class="crossref" href="../nuxeo_automation/Operation.html">Operation</a> call.
This class implements the <a class="crossref" href="../nuxeo_automation/OperationRequest.html#call">call</a> method so it can be invoked as a <a class="crossref" href="../dart_core/Function.html">Function</a>.
Tipically this is called through the <a class="crossref" href="../nuxeo_automation/OperationRegistry.html">OperationRegistry</a>.</p>
<pre class="source">
class OperationRequest {

 static final LOG = new Logger("nuxeo.automation.operation");

 http.Client _client;
 Uri _uri;
 String id;
 Uri _opUri;
 Duration execTimeout, uploadTimeout;

 AutomationUploader _batchUploader;

 OperationRequest._(this.id, this._uri, this._client, {
     this.execTimeout, this.uploadTimeout}) {
   _opUri = Uri.parse("$_uri/$id");
 }

 Future&lt;Operation&gt; get op =&gt; OperationRegistry.get(_uri, _client).then((registry) =&gt; registry[id]);

 /// Call the operation.
 /// Returns a [Future]
 /// Throws [AutomationException]
 Future call({
         dynamic input: null,
         Map&lt;String, Object&gt; params: null,
         Map&lt;String, String&gt; context: null,
         String repository,
         String documentSchemas: "dublincore",
         bool voidOp: false}) =&gt; op.then((Operation op) {

     if (op == null) {
       throw new ArgumentError("No such operation: $id");
     }

     var data = {};

     // Setup the parameters
     if (params != null) {
       data["params"] = {};
       params.forEach((key, value) {
         var param = op[key];
         if (param == null) {
           throw new ArgumentError("No such parameter '$key' for operation ${op.id}.");
         }
         if (value != null) {
           data["params"][key] = value;
         }
       });
     }

     var targetUri = _opUri;

     // Check for batch upload
     if (_hasBatchUpload) {
       if (data["params"] == null) {
         data["params"] = {};
       }
       data["params"]["operationId"] = id;
       data["params"]["batchId"] = batchId;

       // Override the target url
       targetUri = Uri.parse("${_uri}/batch/execute");
     }

     var isMultipart = (input is http.Blob);

     // Setup the input
     if (input != null &amp;&amp; !isMultipart) {
       data["input"] = input;
     }

     // Setup the context
     if (context != null) {
       data["context"] = context;
     }

     var request = _client.post(targetUri, multipart: isMultipart);

     // Setup the headers
     var txTimeout = 5 + ((execTimeout != null) ? execTimeout.inSeconds : 0);

     request.headers.set(HEADER_NX_VOIDOP, voidOp.toString());
     request.headers.set(HEADER_NX_TX_TIMEOUT, txTimeout.toString());
     if (documentSchemas.isNotEmpty) {
       request.headers.set(HEADER_NX_SCHEMAS, documentSchemas);
     }
     if (repository != null) {
       request.headers.set(HEADER_NX_REPOSITORY, repository);
     }

     var json = JSON.stringify(data);

     // The data to send
     var requestData;

     // check for multipart request
     if (isMultipart) {
       var params = new http.Blob(content: json, mimetype: CTYPE_REQUEST_NOCHARSET, filename: "request");
       var formData = new http.MultipartFormData();
       formData.append("request", params);
       formData.append(input.filename, input);
       requestData = formData;
     } else {
       // Set the content type
       request.headers.set(http.HEADER_CONTENT_TYPE, CTYPE_REQUEST_NOCHARSET);
       requestData = json;
     }

     return request
         .send(requestData)
         .catchError((e) {
           throw new AutomationException(e.message);
         })
         .then(_handleResponse);


 });

 _handleResponse(response) {
   var body = response.body,
       json = JSON.parse(body);

   switch (json["entity-type"]) {
     case "document":
       return new Document.fromJSON(json);
       break;
     case "documents":
       var docs = json["entries"].map((doc) =&gt; new Document.fromJSON(doc));

       if (!json.containsKey("isPaginable") || !json["isPaginable"]) {
         return docs;
       }

       return new PaginableDocuments(docs)
           ..totalSize = json["totalSize"]
           ..pageIndex = json["pageIndex"]
           ..pageSize = json["pageSize"]
           ..pageCount = json["pageCount"];

       break;
     case "exception":
       throw new Exception(json["message"]);
       break;
   }
 }

 String get batchId =&gt; _batchUploader.batchId;
 bool get _hasBatchUpload =&gt; _batchUploader != null;

 AutomationUploader get uploader {
   if (_batchUploader == null) {
     _batchUploader = new AutomationUploader(_uri, _client);
   }
   return _batchUploader;
 }
}
</pre>
</div>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="LOG">
<button class="show-code">Code</button>
final         <strong>LOG</strong> <a class="anchor-link"
            href="#LOG"
            title="Permalink to OperationRequest.LOG">#</a>
        </h4>
        <div class="doc">
<pre class="source">
static final LOG = new Logger("nuxeo.automation.operation")
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="batchId">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>batchId</strong> <a class="anchor-link"
            href="#batchId"
            title="Permalink to OperationRequest.batchId">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String get batchId =&gt; _batchUploader.batchId;
</pre>
</div>
</div>
<div class="field"><h4 id="execTimeout">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Duration.html">Duration</a>         <strong>execTimeout</strong> <a class="anchor-link"
            href="#execTimeout"
            title="Permalink to OperationRequest.execTimeout">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Duration execTimeout
</pre>
</div>
</div>
<div class="field"><h4 id="id">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>id</strong> <a class="anchor-link"
            href="#id"
            title="Permalink to OperationRequest.id">#</a>
        </h4>
        <div class="doc">
<pre class="source">
String id
</pre>
</div>
</div>
<div class="field"><h4 id="op">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../nuxeo_automation/Operation.html">Operation</a>&gt;         <strong>op</strong> <a class="anchor-link"
            href="#op"
            title="Permalink to OperationRequest.op">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Future&lt;Operation&gt; get op =&gt; OperationRegistry.get(_uri, _client).then((registry) =&gt; registry[id]);
</pre>
</div>
</div>
<div class="field"><h4 id="uploader">
<button class="show-code">Code</button>
final <a href="../nuxeo_automation/AutomationUploader.html">AutomationUploader</a>         <strong>uploader</strong> <a class="anchor-link"
            href="#uploader"
            title="Permalink to OperationRequest.uploader">#</a>
        </h4>
        <div class="doc">
<pre class="source">
AutomationUploader get uploader {
 if (_batchUploader == null) {
   _batchUploader = new AutomationUploader(_uri, _client);
 }
 return _batchUploader;
}
</pre>
</div>
</div>
<div class="field"><h4 id="uploadTimeout">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Duration.html">Duration</a>         <strong>uploadTimeout</strong> <a class="anchor-link"
            href="#uploadTimeout"
            title="Permalink to OperationRequest.uploadTimeout">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Duration execTimeout, uploadTimeout
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="call">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a> <strong>call</strong>({input: null, <a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/Object.html">Object</a>&gt; params: null, <a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; context: null, <a href="http://api.dartlang.org/dart_core/String.html">String</a> repository, <a href="http://api.dartlang.org/dart_core/String.html">String</a> documentSchemas: "dublincore", <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> voidOp: false}) <a class="anchor-link" href="#call"
              title="Permalink to OperationRequest.call">#</a></h4>
<div class="doc">
<p>Call the operation.
Returns a <a class="crossref" href="../dart_async/Future.html">Future</a>
Throws <a class="crossref" href="../nuxeo_automation/AutomationException.html">AutomationException</a></p>
<pre class="source">
Future call({
       dynamic input: null,
       Map&lt;String, Object&gt; params: null,
       Map&lt;String, String&gt; context: null,
       String repository,
       String documentSchemas: "dublincore",
       bool voidOp: false}) =&gt; op.then((Operation op) {

   if (op == null) {
     throw new ArgumentError("No such operation: $id");
   }

   var data = {};

   // Setup the parameters
   if (params != null) {
     data["params"] = {};
     params.forEach((key, value) {
       var param = op[key];
       if (param == null) {
         throw new ArgumentError("No such parameter '$key' for operation ${op.id}.");
       }
       if (value != null) {
         data["params"][key] = value;
       }
     });
   }

   var targetUri = _opUri;

   // Check for batch upload
   if (_hasBatchUpload) {
     if (data["params"] == null) {
       data["params"] = {};
     }
     data["params"]["operationId"] = id;
     data["params"]["batchId"] = batchId;

     // Override the target url
     targetUri = Uri.parse("${_uri}/batch/execute");
   }

   var isMultipart = (input is http.Blob);

   // Setup the input
   if (input != null &amp;&amp; !isMultipart) {
     data["input"] = input;
   }

   // Setup the context
   if (context != null) {
     data["context"] = context;
   }

   var request = _client.post(targetUri, multipart: isMultipart);

   // Setup the headers
   var txTimeout = 5 + ((execTimeout != null) ? execTimeout.inSeconds : 0);

   request.headers.set(HEADER_NX_VOIDOP, voidOp.toString());
   request.headers.set(HEADER_NX_TX_TIMEOUT, txTimeout.toString());
   if (documentSchemas.isNotEmpty) {
     request.headers.set(HEADER_NX_SCHEMAS, documentSchemas);
   }
   if (repository != null) {
     request.headers.set(HEADER_NX_REPOSITORY, repository);
   }

   var json = JSON.stringify(data);

   // The data to send
   var requestData;

   // check for multipart request
   if (isMultipart) {
     var params = new http.Blob(content: json, mimetype: CTYPE_REQUEST_NOCHARSET, filename: "request");
     var formData = new http.MultipartFormData();
     formData.append("request", params);
     formData.append(input.filename, input);
     requestData = formData;
   } else {
     // Set the content type
     request.headers.set(http.HEADER_CONTENT_TYPE, CTYPE_REQUEST_NOCHARSET);
     requestData = json;
   }

   return request
       .send(requestData)
       .catchError((e) {
         throw new AutomationException(e.message);
       })
       .then(_handleResponse);


});
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
