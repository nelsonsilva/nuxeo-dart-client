        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>utils Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="favicon.ico">
        
        </head>
        <body data-library="utils">
        <div class="page">
        <div class="header">
          <a href="index.html"><div class="logo"></div></a>
          <a href="index.html">Dart Documentation</a>
         &rsaquo; <a href="utils.html">utils</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
<h2><strong>utils</strong> library</h2>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="async">
<button class="show-code">Code</button>
final Future         <strong>async</strong> <a class="anchor-link"
            href="#async"
            title="Permalink to async">#</a>
        </h4>
        <div class="doc">
<p>Returns a <a class="crossref" href="dart_async/Future.html">Future</a> that asynchronously completes to <code>null</code>.</p>
<pre class="source">
Future get async =&gt; new Future.value();
</pre>
</div>
</div>
<div class="field"><h4 id="emptyStream">
<button class="show-code">Code</button>
final Stream         <strong>emptyStream</strong> <a class="anchor-link"
            href="#emptyStream"
            title="Permalink to emptyStream">#</a>
        </h4>
        <div class="doc">
<p>Returns a closed <a class="crossref" href="dart_async/Stream.html">Stream</a> with no elements.</p>
<pre class="source">
Stream get emptyStream =&gt; streamFromIterable([]);
</pre>
</div>
</div>
</div>
<div>
<h3>Functions</h3>
<div class="method"><h4 id="forEachFuture">
<button class="show-code">Code</button>
Future <strong>forEachFuture</strong>(Iterable input, Future fn(element)) <a class="anchor-link" href="#forEachFuture"
              title="Permalink to forEachFuture">#</a></h4>
<div class="doc">
<p>Runs 
<span class="param">fn</span> for each element in 
<span class="param">input</span> in order, moving to the next element
only when the <a class="crossref" href="dart_async/Future.html">Future</a> returned by 
<span class="param">fn</span> completes. Returns a <a class="crossref" href="dart_async/Future.html">Future</a> that
completes when all elements have been processed.</p>
<p>The return values of all <a class="crossref" href="dart_async/Future.html">Future</a>s are discarded. Any errors will cause the
iteration to stop and will be piped through the return value.</p>
<pre class="source">
Future forEachFuture(Iterable input, Future fn(element)) {
 var iterator = input.iterator;
 Future nextElement(_) {
   if (!iterator.moveNext()) return new Future.value();
   return fn(iterator.current).then(nextElement);
 }
 return nextElement(null);
}
</pre>
</div>
</div>
<div class="method"><h4 id="chainToCompleter">
<button class="show-code">Code</button>
void <strong>chainToCompleter</strong>(Future future, Completer completer) <a class="anchor-link" href="#chainToCompleter"
              title="Permalink to chainToCompleter">#</a></h4>
<div class="doc">
<p>Configures 
<span class="param">future</span> so that its result (success or exception) is passed on
to 
<span class="param">completer</span>.</p>
<pre class="source">
void chainToCompleter(Future future, Completer completer) {
 future.then((v) =&gt; completer.complete(v)).catchError((error) {
   completer.completeError(error);
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="tee">
<button class="show-code">Code</button>
<a href="utils/Pair.html">Pair</a>&lt;Stream, Stream&gt; <strong>tee</strong>(Stream stream) <a class="anchor-link" href="#tee"
              title="Permalink to tee">#</a></h4>
<div class="doc">
<p>Creates two single-subscription <a class="crossref" href="dart_async/Stream.html">Stream</a>s that each emit all values and
errors from 
<span class="param">stream</span>. This is useful if 
<span class="param">stream</span> is single-subscription but
multiple subscribers are necessary.</p>
<pre class="source">
Pair&lt;Stream, Stream&gt; tee(Stream stream) {
 var controller1 = new StreamController(sync: true);
 var controller2 = new StreamController(sync: true);
 stream.listen((value) {
   controller1.add(value);
   controller2.add(value);
 }, onError: (error) {
   controller1.addError(error);
   controller2.addError(error);
 }, onDone: () {
   controller1.close();
   controller2.close();
 });
 return new Pair&lt;Stream, Stream&gt;(controller1.stream, controller2.stream);
}
</pre>
</div>
</div>
<div class="method"><h4 id="streamFromIterable">
<button class="show-code">Code</button>
Stream <strong>streamFromIterable</strong>(Iterable iter) <a class="anchor-link" href="#streamFromIterable"
              title="Permalink to streamFromIterable">#</a></h4>
<div class="doc">
<p>Creates a single-subscription stream that emits the items in 
<span class="param">iter</span> and then
ends.</p>
<pre class="source">
Stream streamFromIterable(Iterable iter) {
 var controller = new StreamController(sync: true);
 iter.forEach(controller.add);
 controller.close();
 return controller.stream;
}
</pre>
</div>
</div>
<div class="method"><h4 id="writeStreamToSink">
<button class="show-code">Code</button>
Future <strong>writeStreamToSink</strong>(Stream stream, EventSink sink) <a class="anchor-link" href="#writeStreamToSink"
              title="Permalink to writeStreamToSink">#</a></h4>
<div class="doc">
<p>Pipes all data and errors from 
<span class="param">stream</span> into 
<span class="param">sink</span>. Completes <a class="crossref" href="dart_async/Future.html">Future</a> once

<span class="param">stream</span> is done. Unlike <a class="crossref" href="utils.html#store">store</a>, 
<span class="param">sink</span> remains open after 
<span class="param">stream</span> is
done.</p>
<pre class="source">
Future writeStreamToSink(Stream stream, EventSink sink) {
 var completer = new Completer();
 stream.listen(sink.add,
     onError: sink.addError,
     onDone: () =&gt; completer.complete());
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="store">
<button class="show-code">Code</button>
Future <strong>store</strong>(Stream stream, EventSink sink) <a class="anchor-link" href="#store"
              title="Permalink to store">#</a></h4>
<div class="doc">
<p>Pipes all data and errors from 
<span class="param">stream</span> into 
<span class="param">sink</span>. When 
<span class="param">stream</span> is done,

<span class="param">sink</span> is closed and the returned <a class="crossref" href="dart_async/Future.html">Future</a> is completed.</p>
<pre class="source">
Future store(Stream stream, EventSink sink) {
 var completer = new Completer();
 stream.listen(sink.add,
     onError: sink.addError,
     onDone: () {
       sink.close();
       completer.complete();
     });
 return completer.future;
}
</pre>
</div>
</div>
<div class="method"><h4 id="onDone">
<button class="show-code">Code</button>
Stream <strong>onDone</strong>(Stream stream, void onDone()) <a class="anchor-link" href="#onDone"
              title="Permalink to onDone">#</a></h4>
<div class="doc">
<p>Calls 
<span class="param">onDone</span> once 
<span class="param">stream</span> (a single-subscription <a class="crossref" href="dart_async/Stream.html">Stream</a>) is finished.
The return value, also a single-subscription <a class="crossref" href="dart_async/Stream.html">Stream</a> should be used in
place of 
<span class="param">stream</span> after calling this method.</p>
<pre class="source">
Stream onDone(Stream stream, void onDone()) {
 var pair = tee(stream);
 pair.first.listen((_) {}, onError: (_) {}, onDone: onDone);
 return pair.last;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toByteStream">
<button class="show-code">Code</button>
<a href="byte_stream/ByteStream.html">ByteStream</a> <strong>toByteStream</strong>(Stream&lt;List&lt;int&gt;&gt; stream) <a class="anchor-link" href="#toByteStream"
              title="Permalink to toByteStream">#</a></h4>
<div class="doc">
<p>If 
<span class="param">stream</span> is already a <a class="crossref" href="byte_stream/ByteStream.html">ByteStream</a>, returns it. Otherwise, wraps it in a
<a class="crossref" href="byte_stream/ByteStream.html">ByteStream</a>.</p>
<pre class="source">
ByteStream toByteStream(Stream&lt;List&lt;int&gt;&gt; stream) {
 if (stream is ByteStream) return stream;
 return new ByteStream(stream);
}
</pre>
</div>
</div>
<div class="method"><h4 id="toUint8List">
<button class="show-code">Code</button>
Uint8List <strong>toUint8List</strong>(List&lt;int&gt; input) <a class="anchor-link" href="#toUint8List"
              title="Permalink to toUint8List">#</a></h4>
<div class="doc">
<p>Converts 
<span class="param">input</span> into a <a class="crossref" href="dart_typed_data/Uint8List.html">Uint8List</a>. If 
<span class="param">input</span> is a <a class="crossref" href="dart_typed_data/TypedData.html">TypedData</a>, this just
returns a view on 
<span class="param">input</span>.</p>
<pre class="source">
Uint8List toUint8List(List&lt;int&gt; input) {
 if (input is Uint8List) return input;
 if (input is TypedData) {
   // TODO(nweiz): remove this "as" check when issue 11080 is fixed.
   return new Uint8List.view((input as TypedData).buffer);
 }
 var output = new Uint8List(input.length);
 output.setRange(0, input.length, input);
 return output;
}
</pre>
</div>
</div>
<div class="method"><h4 id="isPlainAscii">
<button class="show-code">Code</button>
bool <strong>isPlainAscii</strong>(String string) <a class="anchor-link" href="#isPlainAscii"
              title="Permalink to isPlainAscii">#</a></h4>
<div class="doc">
<p>Returns whether 
<span class="param">string</span> is composed entirely of ASCII-compatible
characters.</p>
<pre class="source">
bool isPlainAscii(String string) =&gt; _ASCII_ONLY.hasMatch(string);
</pre>
</div>
</div>
<div class="method"><h4 id="encodeString">
<button class="show-code">Code</button>
List&lt;int&gt; <strong>encodeString</strong>(String string, Encoding encoding) <a class="anchor-link" href="#encodeString"
              title="Permalink to encodeString">#</a></h4>
<div class="doc">
<p>Converts 
<span class="param">string</span> into a byte array according to 
<span class="param">encoding</span>.</p>
<pre class="source">
List&lt;int&gt; encodeString(String string, Encoding encoding) {
 // TODO(nweiz): implement this once issue 6284 is fixed.
 return encodeUtf8(string);
}
</pre>
</div>
</div>
<div class="method"><h4 id="decodeString">
<button class="show-code">Code</button>
String <strong>decodeString</strong>(List&lt;int&gt; bytes, Encoding encoding) <a class="anchor-link" href="#decodeString"
              title="Permalink to decodeString">#</a></h4>
<div class="doc">
<p>Converts 
<span class="param">bytes</span> into a <a class="crossref" href="dart_core/String.html">String</a> according to 
<span class="param">encoding</span>.</p>
<pre class="source">
String decodeString(List&lt;int&gt; bytes, Encoding encoding) {
 // TODO(nweiz): implement this once issue 6284 is fixed.
 return decodeUtf8(bytes);
}
</pre>
</div>
</div>
<div class="method"><h4 id="requiredEncodingForCharset">
<button class="show-code">Code</button>
Encoding <strong>requiredEncodingForCharset</strong>(String charset) <a class="anchor-link" href="#requiredEncodingForCharset"
              title="Permalink to requiredEncodingForCharset">#</a></h4>
<div class="doc">
<p>Returns the <a class="crossref" href="dart_io/Encoding.html">Encoding</a> that corresponds to 
<span class="param">charset</span>. Throws a
<a class="crossref" href="dart_core/FormatException.html">FormatException</a> if no <a class="crossref" href="dart_io/Encoding.html">Encoding</a> was found that corresponds to 
<span class="param">charset</span>.

<span class="param">charset</span> may not be null.</p>
<pre class="source">
Encoding requiredEncodingForCharset(String charset) {
 var encoding = Encoding.fromName(charset);
 if (encoding != null) return encoding;
 throw new FormatException('Unsupported encoding "$charset".');
}
</pre>
</div>
</div>
<div class="method"><h4 id="encodingForCharset">
<button class="show-code">Code</button>
Encoding <strong>encodingForCharset</strong>(String charset, [Encoding fallback = Encoding.ISO_8859_1]) <a class="anchor-link" href="#encodingForCharset"
              title="Permalink to encodingForCharset">#</a></h4>
<div class="doc">
<p>Returns the <a class="crossref" href="dart_io/Encoding.html">Encoding</a> that corresponds to 
<span class="param">charset</span>. Returns 
<span class="param">fallback</span> if

<span class="param">charset</span> is null or if no <a class="crossref" href="dart_io/Encoding.html">Encoding</a> was found that corresponds to

<span class="param">charset</span>.</p>
<pre class="source">
Encoding encodingForCharset(
   String charset, [Encoding fallback = Encoding.ISO_8859_1]) {
 if (charset == null) return fallback;
 var encoding = Encoding.fromName(charset);
 return encoding == null ? fallback : encoding;
}
</pre>
</div>
</div>
<div class="method"><h4 id="split1">
<button class="show-code">Code</button>
List&lt;String&gt; <strong>split1</strong>(String toSplit, String pattern) <a class="anchor-link" href="#split1"
              title="Permalink to split1">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="dart_core/String.html#split">String.split</a>, but only splits on the first occurrence of the pattern.
This will always return an array of two elements or fewer.</p>
<pre><code>split1("foo,bar,baz", ","); //=&gt; ["foo", "bar,baz"]
split1("foo", ","); //=&gt; ["foo"]
split1("", ","); //=&gt; []
</code></pre>
<pre class="source">
List&lt;String&gt; split1(String toSplit, String pattern) {
 if (toSplit.isEmpty) return &lt;String&gt;[];

 var index = toSplit.indexOf(pattern);
 if (index == -1) return [toSplit];
 return [
   toSplit.substring(0, index),
   toSplit.substring(index + pattern.length)
 ];
}
</pre>
</div>
</div>
<div class="method"><h4 id="urlDecode">
<button class="show-code">Code</button>
String <strong>urlDecode</strong>(String encoded) <a class="anchor-link" href="#urlDecode"
              title="Permalink to urlDecode">#</a></h4>
<div class="doc">
<p>Decodes a URL-encoded string. Unlike <a class="crossref" href="dart_core/Uri.html#decodeComponent">Uri.decodeComponent</a>, this includes
replacing <code>+</code> with <code> </code>.</p>
<pre class="source">
String urlDecode(String encoded) =&gt;
 Uri.decodeComponent(encoded.replaceAll("+", " "));
</pre>
</div>
</div>
<div class="method"><h4 id="mapToQuery">
<button class="show-code">Code</button>
String <strong>mapToQuery</strong>(Map&lt;String, String&gt; map) <a class="anchor-link" href="#mapToQuery"
              title="Permalink to mapToQuery">#</a></h4>
<div class="doc">
<p>Converts a <a class="crossref" href="dart_core/Map.html">Map</a> from parameter names to values to a URL query string.</p>
<pre><code>mapToQuery({"foo": "bar", "baz": "bang"});
//=&gt; "foo=bar&amp;baz=bang"
</code></pre>
<pre class="source">
String mapToQuery(Map&lt;String, String&gt; map) {
 var pairs = &lt;List&lt;String&gt;&gt;[];
 map.forEach((key, value) =&gt;
     pairs.add([Uri.encodeQueryComponent(key),
                Uri.encodeQueryComponent(value)]));
 return pairs.map((pair) =&gt; "${pair[0]}=${pair[1]}").join("&amp;");
}
</pre>
</div>
</div>
<div class="method"><h4 id="queryToMap">
<button class="show-code">Code</button>
Map&lt;String, String&gt; <strong>queryToMap</strong>(String queryList) <a class="anchor-link" href="#queryToMap"
              title="Permalink to queryToMap">#</a></h4>
<div class="doc">
<p>Converts a URL query string (or <code>application/x-www-form-urlencoded</code> body)
into a <a class="crossref" href="dart_core/Map.html">Map</a> from parameter names to values.</p>
<pre><code>queryToMap("foo=bar&amp;baz=bang&amp;qux");
//=&gt; {"foo": "bar", "baz": "bang", "qux": ""}
</code></pre>
<pre class="source">
Map&lt;String, String&gt; queryToMap(String queryList) {
 var map = {};
 for (var pair in queryList.split("&amp;")) {
   var split = split1(pair, "=");
   if (split.isEmpty) continue;
   var key = urlDecode(split[0]);
   var value = urlDecode(split.length &gt; 1 ? split[1] : "");
   map[key] = value;
 }
 return map;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Classes</h3>
          <div class="type">
          <h4>
            <a href="utils/Pair.html"><strong>Pair&lt;E, F&gt;</strong></a>
          </h4>
          </div>
          
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="client-live-nav.js"></script>
        </body></html>
        
